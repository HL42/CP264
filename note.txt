C compiling four steps:(will be on mid/final)
	1. Pre-processing: Resolve lines with pre-processor directives, line start with #
	2. Compilation: Convert the C program into assembly program
	3. Assembling: convert the assembly to binary format, called object program
	4. Linking: link necessary object programs to create an executable program, a binary machine code program

除数其中一边有小数 则结果为小数

char: 
32: 占一位
64: 占一位

short: 
32: 2
64: 2

int :
32: 4
64: 4

long:
32: 4
64: 8

float:
32: 4
64: 8

double:
32: 8
64: 8

pointer:（特殊变量）
存放内存地址的变量

非声明指针变量的场景下：* 为解指针

& = 取地址符

特殊指针：
NULL 指针:空指针
int *p = NULL;

Generic point 泛指针:
void *p;

双指针：



Array:
a[1] == *(a+1)
*(a+1) == a + 1 = a+1*4
相对来说指针比数组快
数组可以直接赋值

动态数组：
int length = 5;
int *a = (int *)malloc(sizeof(int)*length);


String:
The end of string is marked by the null character ‘\0’ 

字符串遍历
void print_string(char *s) {
    while (*s != '\0') {
        printf("%c", *s);
        s++;
    }
}
// 等价简写：while (*s) { printf("%c", *s++); }

字符串拷贝
void my_strcpy(char *dest, const char *src) {
    while ((*dest++ = *src++) != '\0'); // 逐个字符复制，包括 '\0'
}

字符串比较（字典序）
int my_strcmp(const char *s1, const char *s2) {
    while (*s1 && *s2 && *s1 == *s2) {
        s1++;
        s2++;
    }
    return (*s1 > *s2) ? 1 : (*s1 < *s2) ? -1 : 0;
}

字符串反转
void reverse_string(char *s) {
    char *end = s;
    while (*end) end++; // 找到 '\0' 位置
    end--;              // 回退到最后一个有效字符
    
    while (s < end) {
        char temp = *s;
        *s++ = *end;
        *end-- = temp;
    }
}

String operation:
-Reading strings from stdio (keyboard)
stdio has three functions for getting input from stdin keyboard.
 - getchar() – get and return a character from keyboard
 - gets(*p) – get a string for keyboard and store in p
 - scanf("%s", char *p) – get string from keyboard,
 - fgets(str)	安全	读取指定长度	fgets(str, 20, stdin);

strlen(const char*) - 返回字符串长度 - strlen("Hello") → 5	

strcpy(dest, src) - 字符串复制 - strcpy(dest, "cp264")

strcat(dest, src) - 字符串拼接 - strcat(str, " World")

strcmp(s1, s2) - 字符串比较 - strcmp("Apple", "Banana") → -1

strstr(s1, s2) - 查找子串 - strstr("Hello", "lo") → 指向 "lo" 的地址

strtok(str, delim) - 分割字符串 - 首次调用需传入字符串，后续用 NULL
char str[] = "cp264,Data Structures;2024";
char *token = strtok(str, ",; "); // 分隔符为逗号、分号、空格

while (token != NULL) {
    printf("%s\n", token);
    token = strtok(NULL, ",; ");
}
// 输出：
// cp264
// Data
// Structures
// 2024


User define types: Structure（结构体）类似java的类去除方法部分
自定义：设计图纸
多个变量的集合
Structure: 有返回值 有参数
struct Person {
    int age;
    char name[20];
};

初始化
struct 结构体名 变量名;
struct Person p;

如何赋值：
p.age = 20;
p.name = "Tom";

struct point *pp;
(*pp).x = 10;
也可以写成
pp->x = 10;

Typedef:
typedef 数据类型 别名
typedef int zx

typedef struct xx {

}别名

typedef struct{

}别名
用完这个后就不需要再加struct来声明结构体


Union: 
union Data {
    int i;
    double d;
    char str[20];
};
union Data data; // 声明联合体变量

it can hold different types of data, but can only hold one type of data at a time. 声明不同数据类型的变量可以共享同一个内存空间。
所有成员共享同一块内存，同一时间只能存储一个成员的值。

允许将不同类型的数据存储在一个变量中

Enum:
const int colors[] = {
    0x00000001, // 紫色
    0x00000002, // 灰色
    ...,
    0xFF00FF00; // 黄色
};

enum color {
    red, green, blue; 
};
方便地访问多个有限类型的变量

strcpy: String copy用于复制

sizeOf = 返回在内存中占的字节数
size_t = 返回类型所占的内存大小

内存分类：
1. 静态/全局内存
2. 自动内存（stack)(栈内存）不受控制
3. 动态内存（heap)(堆内存）受控制（Pointers are used in dynamic memory allocation and management.)

malloc(memory allocate): 动态内存分配
void* malloc(size_t);
如果成功：返回堆内存上分配的内存指针
如果失败：返回空指针NULL

int *p  = (int*)malloc(sizeof(int));
*p = 3;
printf("%d", *p);
free(p);

free: 释放动态内存

时间复杂度:

1.常数复杂度O(1)
2.线性复杂度O(n)
3. O(n^2)
4. O(logn)
5. O(n log n)
6. O(2^n)

空间复杂度
ABT


数据结构：
----------------------------
线性表：
n个相同类型的数据组合在一起就是线性表 
特点：
 -存在唯一的第一个被称作头节点
 -存在唯一的最后一个被称作尾节点

类型1: 顺序表 (不方便)
 - 连续的内存单元依次存储各个元素

存储结构
#define MAXSIZE = 100
typedef int ElemType;

typedef struct {
    ElemType data[MAXSIZE];
    int length;
}SeqList

// 初始化
void initList() {
    L->length = 0; 
    // 分配内存
    SeqList *L = (SeqList *)malloc(sizeof(SeqList));
    L->data = (ElemType *)malloc(sizeof(ElemType) * MAXSIZE);
    L->length = 0;
    return L;
}

// 遍历
void listElem(SeqList *L){
    for(int i = 0; i < L->length; i++){
        printf("%d ", L->data[i]);
    }
}

// 在尾部添加元素
int appendElem (SeqList *L, ElemType e){
    if(L->length >= MAXSIZE){
        return 0;
    }

    L->data[L->length] = e;
    L->length++;
    return 1;
}

// 插入 最好时间复杂度O(1) 最坏时间复杂度O(n)   
int insertElem(SeqList *L, int pos, ElemType e) {
    if(pos <= L->Lenght){
        for(int i = L->length-1; i >= pos - i; i--){
            L->data[i+1] = L=>data[i];
        }
        L->data[pos-1] = e;
        L->length++;
    }
    return 1;
}

// 删除
int deleteElem(SeqList *L, int pos, ElemType *e) {
    *e = L->data[pos-1];
    if(pos < L->length){
        for(int i = pos; i < L->length; i++){
            L->data[i-1] = L->data[i];
        }
    }
    L->length--;
    return 1;
}

// 查找子串
int findElem(SeqList *L, ElemType e, int *pos) {
    for(int i = 0; i < L->length; i++){
        if(L->data[i] == e){
            return i + 1;
        }
    }
    return 0;
}

Linked lists(链表){
    是一种动态数据结构(dynamic data structure)
    与数组不同，这个是由指针将每个元素（节点）连接起来。
    可以连续也可以不连续
}
[][--]->[][--]-> 
Node:
 - 包含两个部分
  - 数据域(Data): 存储实际的数据
  - 指针域(Next): 指向下一个节点的地址
 - 头节点(Head): Linked list的开始节点，通常指向第一个字节的指针.
 - 尾节点(Tail): Linked list的结束节点，它的next通常指向NULL,表示链表结束。

typedef int ElemType;
typedef stuct {
    ElemType data;
    struct Node *next;
}

1.Singly Linked List: 每个节点只有一个指针，指向下一个节点
the last node point to NULL;
Node can be done in 2 Methods:
1. Static method: uses declaration to allocate memory for nodes
2. Dynamic method: uses malloc(sizeof(NODE)) to allocate memory for nodes
// Dynamic method is the commonly used Methods for creating linked list nodes

Creating a linked list:

1. Create Nodes
typedef struct node
{
    int data;
    struct node *next;
}NODE;

2. Dynamic method:
NODE *p1 = (NODE *)malloc(sizeof(NODE));
p1->data = 10;
p1->next = NULL;

// Traversing
// time complexity: O(n)
// Space complexity: O(1)
void display(NODE *start) {
    NODE *ptr = start;
    while (ptr != NULL) {
        printf("%d ", ptr->data);
        ptr = ptr->next;
    }
}

// Recursive Traversing
// time complexity: O(n)
// Space complexity: O(n)
void display_recursive(NODE *start) {
    if (start == NULL) return;
    printf("%d ", start->data);
    display_recursive(start->next);
}

// Searching through the linked list by a key
// time complexity: O(n)
// Space complexity: O(1)
int key = value;
NODE *p = start;
while(p != NULL)
{
    if(p->data == key)
    {
        break;
    }
    p = p->next;
}
return p;

Insert Operation:
1. Insert at the beginning
2. Insert at the end
3. Insert after a given position
4. Insert before a given node


1. at the beginning
// Time O(1), Space O(1)
NODE* insert_beg(NODE *start, NODE *np//如果已经创建了节点就可以使用这样的方法)
{
    np->next = start;
    start = np;
    return start;
}

2. at the end
// Time O(n), Space O(1)
void insert_end (NODE **startp, NODE *np) 
{
    NODE *ptr = *startp;
    if(ptr == NULL) 
    {
        *startp = np;
    }
    while(ptr->next)
    {
        ptr = ptr->next;
        ptr->next = np;
    }
}

3. Insert_after
// Time O(n), Space O(1)
void insert_after(NODE *start, NODE *np, int key)
{
    NODE *ptr = *startp;
    while(ptr != NULL && ptr->data != key)
    {
        ptr = ptr->next;
    }

    if(ptr != NULL && ptr->data == key){
        np->next = ptr->next;
        ptr->next = np;
    }
}

// Delete 
1. First node
2. Last node
3. A specific node
4. Node before/After a specific node


1. First Node
// Time O(1), Space O(1)
void delete_beg(NODE **startp)
{
    NODE *ptr = *startp;
    if(ptr != NULL) 
    {
        *startp = ptr->next;
        free(ptr);
    }
}
2.Doubly Linked List: 每个节点有两个指针，分别指向前一个节点和后一个节点




QUEUE;


STACK:ABT
LIFO
- When the stack is empty:(Underflow) top = -1
- When the stack is full:(Overflow) top = max - 1

两种实现方法
 1.Array stack
 用一个数组存储元素，一个变量top记录栈顶位置。
    例子 ：
    假设数组最大容量是 3：
    初始状态：数组为空，top = -1（表示空栈）。
    Push 10 → top=0，数组[0]=10  
    Push 20 → top=1，数组[1]=20  
    Push 30 → top=2，数组[2]=30  
    Pop → 移除30，top=1  
    缺点 ：数组大小固定，满了就不能再 Push（溢出 ）。

2. linked List stack
    用链表的头节点作为栈顶，每次 Push 插入到头部，Pop 删除头节点。
    Push 10 → 链表：10 → NULL  
    Push 20 → 链表：20 → 10 → NULL  
    Push 30 → 链表：30 → 20 → 10 → NULL  
    Pop → 移除30，链表变为 20 → 10 → NULL  
    优点 ：动态扩容，不会溢出（除非内存用完）。

Stack Application
 - Infix
    运算符在两个操作数中间，比如 3 + 4。
    问题 ：需要括号解决优先级问题，计算机处理起来麻烦。
 - Postfix
    运算符在操作数后面，比如 3 4 +。
    优点 ：不需要括号，计算机用栈直接计算。
 - Prefix
    运算符在操作数前面，比如 + 3 4。
    用途 ：某些编程语言（如Lisp）使用。

tree
A tree data structure is the implement of an abstract tree in programming language.

1. Nodes(Vertices)
2. Nodes-to-nodes (Edges)

Tree T satisfies the following conditions.
1. Each node has zero or more children.
2. There is a unique node without parent, called root. 
3. There is a unique path from the root to any other node. A path connecting node n to the root is called a root-to-node path.

AVL Tree:
 -It is height-balanced BST and self-balacing insert and delete operations.
 Step1:
    - Do BST insert/delete operations
Step2:
    - Do AVL Rotation

Time complexity:
 -Insert and Delete operation is O(logn)
 Space complexity:
 -Insert and Delete operation is o(1)


BFS (Breadth-First Search)(广度优先搜索):
 - BFS就像一层层扫楼，先找第一层（根节点），再找第二层，第三层... 直到找到目标。

DFS (Depth-First Search)(深度优先搜索):
 - DFS就像一根筋钻到底，先往左子树最深处找，找不到再回溯，换右子树继续钻。
 
BFS遍历顺序 ：1 → 2 → 3 → 4 → 5 → 6
（一层层来，像扫雷）
DFS遍历顺序 ：1 → 2 → 4 → 5 → 3 → 6
（先钻到最左，再回溯）


四种失衡类型及修复方法
左左 (LL)
在左子树的左子树插入节点（平衡因子>1）
单右旋
（以失衡节点为中心）
右右 (RR)
在右子树的右子树插入节点（平衡因子<-1）
单左旋
（以失衡节点为中心）
左右 (LR)
在左子树的右子树插入节点
先左旋左子树，再右旋失衡节点
右左 (RL)
在右子树的左子树插入节点
先右旋右子树，再左旋失衡节点

Red Black Tree
- 红黑树（Red-Black Tree）

RBT search, insert, delete operation can be done in time O(log n) and space O(1)

RBG must meat the following properties:
 1. Root must be black or red
 2. The color of the root node is black, and all NULL child are viewed as black node
 3. The child nodes of a red node are black nodes
 4. For any node, every path from the node to any of its NULL node has the same number of black nodes

Insertion:
 Normal insertion case:
  - If the node is inserted at the root, the node is colored red.
 Check the parent node color:
  - If the parent node is red, need to fix the tree
  - If the parent node is black, 直接插入
 Method to fix:
  - Case 1: 叔父节点是红色，重新着色
  - Case 2: 叔父节点是黑色，旋转 + 变色

HASH MAP:

Create traditional way to create Hash map:
 1. Using arrays, the search time is O(n) in worst case
 2. Using AVL trees, the search time is O(log n) in worst case.

hash设计原理：
目标：均匀分布键，减少碰撞

经典方法：
除留余数法：h(k) = k % m（m选质数，如97）
字符串哈希：累加字符ASCII码后取余（课程例子）

解决碰撞的方法：
 1.开放寻址法（如线性探测）
 2.链式法（如链表）

1. Linear Probing
冲突时：按顺序找下一个空位（比如往后挨个找）
探测函数：h(k, i) = (h(k) + i) % m（i是探测次数）

2. Chaining
原理
冲突时：在同一个位置挂链表（或树）
结构：哈希表数组每个元素是链表头指针


HEAPS
- Bianry HEAPS


- Fibonnaci HEAPS




FINAL REVIEW:
Converage: Week 4 - 12

NEED TO KNOW HOW TO BUILD HUFFMAN Tree / Expression tree
no programming questions on avl tree